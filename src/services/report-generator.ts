// Report Generator - Generic markdown report generation for ANY brand

import fs from 'fs/promises';
import path from 'path';
import type { ResearchFinding, ResearchSource } from '../types/research-types.js';
import type { BrandConfiguration } from '../types/project-types.js';

export interface ReportOptions {
  title: string;
  includeConfidence?: boolean;
  includeSources?: boolean;
  groupByTopic?: boolean;
  maxFindings?: number;
}

export class ReportGenerator {
  private brandConfig: BrandConfiguration;

  constructor(brandConfig: BrandConfiguration) {
    this.brandConfig = brandConfig;
  }

  async generateMarkdownReport(
    findings: ResearchFinding[],
    options: ReportOptions
  ): Promise<string> {
    const brandSlug = this.brandConfig.brandName.toLowerCase().replace(/\s+/g, '-');
    const outputDir = path.join(process.cwd(), 'output', brandSlug);
    await fs.mkdir(outputDir, { recursive: true });

    const timestamp = new Date().toISOString().split('T')[0];
    const filename = `${brandSlug}-${options.title.toLowerCase().replace(/\s+/g, '-')}-${timestamp}.md`;
    const filepath = path.join(outputDir, filename);

    const content = this.buildMarkdownContent(findings, options);

    await fs.writeFile(filepath, content, 'utf-8');

    console.log(`✅ Report generated: ${filepath}`);
    return filepath;
  }

  private buildMarkdownContent(
    findings: ResearchFinding[],
    options: ReportOptions
  ): string {
    // Apply max findings limit
    const limitedFindings = options.maxFindings
      ? findings.slice(0, options.maxFindings)
      : findings;

    let content = `# ${this.brandConfig.brandName} - ${options.title}\n\n`;
    content += `**Generated**: ${new Date().toISOString()}\n`;
    content += `**Total Findings**: ${limitedFindings.length}\n`;

    // Add brand context
    content += `\n## Brand Context\n\n`;
    content += `- **Industry**: ${this.brandConfig.industry}\n`;
    content += `- **Category**: ${this.brandConfig.category}\n`;
    if (this.brandConfig.companyProfile) {
      content += `- **Founded**: ${this.brandConfig.companyProfile.founded}\n`;
      content += `- **Channels**: ${this.brandConfig.companyProfile.channels.join(', ')}\n`;
    }

    content += `\n---\n\n`;

    if (options.groupByTopic) {
      // Group findings by topic
      const byTopic = new Map<string, ResearchFinding[]>();
      limitedFindings.forEach((f) => {
        if (!byTopic.has(f.topic)) {
          byTopic.set(f.topic, []);
        }
        byTopic.get(f.topic)!.push(f);
      });

      byTopic.forEach((topicFindings, topic) => {
        content += `## ${topic}\n\n`;
        content += `**Findings**: ${topicFindings.length}\n\n`;

        topicFindings.forEach((finding, i) => {
          content += this.formatFinding(finding, i + 1, options);
        });

        content += `---\n\n`;
      });
    } else {
      // List findings sequentially
      limitedFindings.forEach((finding, i) => {
        content += this.formatFinding(finding, i + 1, options);
      });
    }

    // Summary section
    content += `## Summary\n\n`;
    content += `This report contains ${limitedFindings.length} research findings for ${this.brandConfig.brandName}.\n\n`;

    if (options.includeConfidence) {
      const avgConfidence = this.calculateAverageConfidence(limitedFindings);
      content += `**Average Confidence Score**: ${avgConfidence.toFixed(1)}/10\n\n`;
    }

    const uniqueTopics = new Set(limitedFindings.map((f) => f.topic));
    content += `**Topics Covered**: ${uniqueTopics.size}\n`;
    uniqueTopics.forEach((topic) => {
      content += `- ${topic}\n`;
    });
    content += `\n`;

    // Add disclaimer
    content += `---\n\n`;
    content += `*This report was generated by Horizon Brand Builder Pro.*\n`;
    content += `*All findings should be verified and cross-referenced with original sources.*\n`;

    return content;
  }

  private formatFinding(
    finding: ResearchFinding,
    index: number,
    options: ReportOptions
  ): string {
    let content = `### Finding ${index}: ${finding.topic}\n\n`;
    content += `${finding.content}\n\n`;

    if (options.includeConfidence && finding.confidence !== undefined) {
      const confidenceLabel = this.getConfidenceLabel(finding.confidence);
      content += `**Confidence**: ${finding.confidence}/10 (${confidenceLabel})\n\n`;
    }

    if (options.includeSources && finding.sources.length > 0) {
      content += `**Sources**:\n`;
      finding.sources.forEach((source: ResearchSource, i: number) => {
        content += `${i + 1}. [${source.title}](${source.url})`;
        if (source.tier) {
          content += ` (Tier ${source.tier})`;
        }
        content += `\n`;
      });
      content += `\n`;
    }

    if (finding.timestamp) {
      content += `*Researched: ${new Date(finding.timestamp).toLocaleDateString()}*\n\n`;
    }

    return content;
  }

  private calculateAverageConfidence(findings: ResearchFinding[]): number {
    const withConfidence = findings.filter((f) => f.confidence !== undefined);
    if (withConfidence.length === 0) return 0;

    const sum = withConfidence.reduce((acc, f) => acc + (f.confidence || 0), 0);
    return sum / withConfidence.length;
  }

  private getConfidenceLabel(confidence: number): string {
    if (confidence >= 9) return 'Very High';
    if (confidence >= 8) return 'High';
    if (confidence >= 6) return 'Medium';
    if (confidence >= 4) return 'Low';
    return 'Very Low';
  }

  async generateHTMLReport(
    findings: ResearchFinding[],
    options: ReportOptions
  ): Promise<string> {
    const brandSlug = this.brandConfig.brandName.toLowerCase().replace(/\s+/g, '-');
    const outputDir = path.join(process.cwd(), 'output', brandSlug);
    await fs.mkdir(outputDir, { recursive: true });

    const timestamp = new Date().toISOString().split('T')[0];
    const filename = `${brandSlug}-${options.title.toLowerCase().replace(/\s+/g, '-')}-${timestamp}.html`;
    const filepath = path.join(outputDir, filename);

    const html = this.buildHTMLContent(findings, options);

    await fs.writeFile(filepath, html, 'utf-8');

    console.log(`✅ HTML report generated: ${filepath}`);
    return filepath;
  }

  private buildHTMLContent(findings: ResearchFinding[], options: ReportOptions): string {
    // Simple HTML generation (in production, use a proper template engine)
    let html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${this.brandConfig.brandName} - ${options.title}</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
    h1 { color: #333; }
    h2 { color: #555; border-bottom: 2px solid #ddd; padding-bottom: 10px; }
    .finding { background: #f9f9f9; padding: 15px; margin: 15px 0; border-left: 4px solid #007bff; }
    .confidence { color: #28a745; font-weight: bold; }
    .sources { margin-top: 10px; }
    .sources a { color: #007bff; text-decoration: none; }
    .sources a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <h1>${this.brandConfig.brandName} - ${options.title}</h1>
  <p><strong>Generated:</strong> ${new Date().toISOString()}</p>
  <p><strong>Total Findings:</strong> ${findings.length}</p>
  <hr>
`;

    findings.forEach((finding, i) => {
      html += `  <div class="finding">
    <h3>Finding ${i + 1}: ${finding.topic}</h3>
    <p>${finding.content}</p>
`;

      if (options.includeConfidence && finding.confidence) {
        html += `    <p class="confidence">Confidence: ${finding.confidence}/10</p>\n`;
      }

      if (options.includeSources && finding.sources.length > 0) {
        html += `    <div class="sources">
      <strong>Sources:</strong>
      <ul>
`;
        finding.sources.forEach((source: ResearchSource) => {
          html += `        <li><a href="${source.url}" target="_blank">${source.title}</a></li>\n`;
        });
        html += `      </ul>
    </div>
`;
      }

      html += `  </div>\n`;
    });

    html += `</body>
</html>`;

    return html;
  }
}

export default ReportGenerator;
